---
import "../styles/global.scss";
import { ViewTransitions } from 'astro:transitions';

export interface SEOProps {
  title?: string;
  description?: string;
  canonical?: string;
  ogImage?: string;
  keywords?: string[];
  structuredData?: object;
  noindex?: boolean;
  ogType?: string;
  author?: string;
}

const {
  title = "Template Astro - Site Web Moderne et Performant",
  description = "Template Astro optimisé pour créer des sites web rapides, modernes et SEO-friendly. Intégration TinaCMS, animations fluides et composants réutilisables.",
  canonical = Astro.url.href,
  ogImage = `${Astro.url.origin}/og-image.png`,
  keywords = ["astro", "template", "web design", "cms", "performance", "seo"],
  structuredData,
  noindex = false,
  ogType = "website",
  author = "Votre Entreprise",
} = Astro.props as SEOProps;

// Structured data par défaut Organization + WebSite
const defaultStructuredData = {
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Organization",
      "@id": `${Astro.url.origin}/#organization`,
      "name": "Votre Entreprise",
      "url": Astro.url.origin,
      "logo": {
        "@type": "ImageObject",
        "url": `${Astro.url.origin}/favicon.png`,
      },
      "sameAs": [
        "https://twitter.com/yourcompany",
        "https://linkedin.com/company/yourcompany",
        "https://github.com/yourcompany"
      ],
      "contactPoint": {
        "@type": "ContactPoint",
        "contactType": "Customer Service",
        "email": "contact@example.com",
        "availableLanguage": ["fr", "en"]
      }
    },
    {
      "@type": "WebSite",
      "@id": `${Astro.url.origin}/#website`,
      "url": Astro.url.origin,
      "name": title,
      "description": description,
      "publisher": {
        "@id": `${Astro.url.origin}/#organization`
      },
      "inLanguage": "fr-FR"
    },
    {
      "@type": "WebPage",
      "@id": `${canonical}#webpage`,
      "url": canonical,
      "name": title,
      "description": description,
      "isPartOf": {
        "@id": `${Astro.url.origin}/#website`
      },
      "datePublished": "2025-01-01T00:00:00+00:00",
      "dateModified": new Date().toISOString(),
      "inLanguage": "fr-FR"
    }
  ]
};

const finalStructuredData = structuredData || defaultStructuredData;

// Generate robots meta
const robotsContent = noindex ? "noindex, nofollow" : "index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1";
---
<!doctype html>
<html lang="fr" dir="ltr">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
		
		<!-- Favicons & Icons -->
		<link rel="icon" type="image/svg+xml" href="/favicon.png" />
		<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
		<link rel="manifest" href="/site.webmanifest" />
		<meta name="theme-color" content="#ffffff" />
		
		<!-- DNS Prefetch & Preconnect -->
		<link rel="dns-prefetch" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
		<link rel="dns-prefetch" href="https://fonts.gstatic.com" />
		
		<!-- Generator -->
		<meta name="generator" content={Astro.generator} />
		
		<!-- SEO Principal -->
		<title>{title}</title>
		<meta name="description" content={description} />
		<meta name="keywords" content={keywords.join(", ")} />
		<meta name="author" content={author} />
		<link rel="canonical" href={canonical} />
		
		<!-- Robots -->
		<meta name="robots" content={robotsContent} />
		<meta name="googlebot" content={robotsContent} />
		<meta name="bingbot" content={robotsContent} />
		
		<!-- Open Graph / Facebook -->
		<meta property="og:type" content={ogType} />
		<meta property="og:url" content={canonical} />
		<meta property="og:title" content={title} />
		<meta property="og:description" content={description} />
		<meta property="og:image" content={ogImage} />
		<meta property="og:image:width" content="1200" />
		<meta property="og:image:height" content="630" />
		<meta property="og:locale" content="fr_FR" />
		<meta property="og:site_name" content="Template Astro" />
		
		<!-- Twitter Card -->
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:url" content={canonical} />
		<meta name="twitter:title" content={title} />
		<meta name="twitter:description" content={description} />
		<meta name="twitter:image" content={ogImage} />
		<meta name="twitter:image:alt" content={title} />
		<meta name="twitter:creator" content="@yourcompany" />
		
		<!-- Additional SEO -->
		<meta name="format-detection" content="telephone=no" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		
		<!-- Structured Data (JSON-LD) -->
		<script type="application/ld+json" set:html={JSON.stringify(finalStructuredData)}></script>
		
		<!-- Performance hints: preload CSS retiré pendant le dev pour éviter les warnings inutiles -->
		
		<!-- View Transitions (Astro 2025) -->
		<ViewTransitions />
	</head>
	<body>
		<slot />
		<script is:inline>
// Système "reveal once" : fige les éléments après leur première apparition
(() => {
	const selectors = [
		'.scroll-reveal',
		'.scroll-reveal-delayed',
		'.scroll-reveal-scale',
		'.animate-on-scroll',
		'.animate-on-scroll-delayed',
		'.reveal-tilt-scale'
	];
	const nodes = document.querySelectorAll(selectors.join(','));
	if (!nodes.length) return;

	const preferOnce = true; // mettre false pour réactiver animations multi-scroll

	const markRevealed = (el) => {
		el.classList.add('is-revealed');
		// Supprime les propriétés scroll-timeline pour éviter re-trigger (navigateurs modernes)
		el.style.animationTimeline = 'none';
	};

	if (preferOnce) {
		nodes.forEach(el => {
			// Ajout automatique du modificateur si pas déjà présent
			if (!el.classList.contains('reveal-once')) {
				el.classList.add('reveal-once');
			}
		});
	}

		const supportsViewTimeline = CSS.supports('animation-timeline: view()');

		// Fallback intersection observer pour marquer .is-revealed et déclencher animation
		const io = new IntersectionObserver((entries) => {
		entries.forEach(entry => {
			if (entry.isIntersecting) {
				const el = entry.target;
					if (!supportsViewTimeline) {
						// Appliquer animation classique seulement maintenant (évite apparition sans transition)
						const baseAnim = el.classList.contains('scroll-reveal-scale') || el.classList.contains('reveal-tilt-scale')
							? 'scroll-reveal-scale'
							: 'scroll-reveal-rise';
						const delay = el.classList.contains('scroll-reveal-delayed') || el.classList.contains('animate-on-scroll-delayed') ? 150 : 0;
						el.style.animation = `${baseAnim} var(--reveal-duration,700ms) var(--reveal-ease, cubic-bezier(0.16,1,0.3,1)) both`;
						if (delay) el.style.animationDelay = delay + 'ms';
					}
							// Si support view-timeline: marquer révélé dès première intersection pour garder état final
							if (supportsViewTimeline && el.classList.contains('reveal-once') && !el.classList.contains('is-revealed')) {
								markRevealed(el);
							} else if (!supportsViewTimeline && el.classList.contains('reveal-once') && !el.classList.contains('is-revealed')) {
								const onEnd = () => { markRevealed(el); el.removeEventListener('animationend', onEnd); };
								el.addEventListener('animationend', onEnd, { once: true });
							}
				// Une fois intersecté on n'observe plus pour performance
				io.unobserve(el);
			}
		});
	}, { threshold: 0.35 });

	nodes.forEach(el => io.observe(el));
})();
		</script>
		
		<!-- Scripts d'animation désactivés temporairement pour diagnostiquer le blanc -->
		<!-- TODO: Réactiver après avoir vérifié le rendu de base -->
	</body>
</html>
