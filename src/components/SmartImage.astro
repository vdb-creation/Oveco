---
import { Image as UnpicImage, Source as UnpicSource } from "@unpic/astro";
import type { ImageMetadata } from "astro";
import path from "node:path";
import { stat as fsStat } from "node:fs/promises";

const PUBLIC_DIR = path.join(process.cwd(), "public");

/** Retourne true si le fichier existe */
async function exists(p: string) {
  try { 
    await fsStat(path.join(PUBLIC_DIR, p.replace(/^\//, ""))); 
    return true; 
  } catch { 
    return false; 
  }
}

/** Ajoute un query ?v=mtime aux chemins locaux */
async function versioned(p?: string) {
  if (!p || !p.startsWith("/")) return p;
  try {
    const abs = path.join(PUBLIC_DIR, p.replace(/^\//, ""));
    const s = await fsStat(abs);
    return `${p}?v=${Math.floor(s.mtimeMs)}`;
  } catch { return p; }
}

// Manifests (LQIP d'abord, puis BlurHash)
import lqipManifest from "../lqip-manifest.json";
import blurManifest from "../blurhash-manifest.json";

type Layout = "constrained" | "fullWidth" | "fixed";
type PlaceholderKind = "blurhash" | "dominantColor" | "lqip";
type FitKind = "contain" | "cover" | "fill" | "none" | "scale-down";

interface Props {
  cmsSrc?: string;                       // Tina: /uploads/... ou /upload/...
  fallback?: ImageMetadata | string;     // import Astro ou string
  alt: string;

  width?: number;
  height?: number;
  aspectRatio?: number;

  context?: "hero" | "about" | "galerie" | "default"; // Ajout du contexte pour la taille
  isAvatar?: boolean; // Pour border-radius 100% sur les avatars

  layout?: Layout;
  breakpoints?: number[];
  sizes?: string;

  priority?: boolean;
  placeholder?: PlaceholderKind;         // utile si src distante
  background?: string;                   // override manuel

  quality?: number;
  fit?: FitKind;
  position?: string;

  class?: string;                        // appliqué à <img>
  style?: string;                        // appliqué au wrapper
  decoding?: "sync" | "async" | "auto";
  loading?: "lazy" | "eager";

  formats?: Array<"avif" | "webp">;      // ordre de préférence
  // STRICT: quel format utiliser pour le <img> fallback (jamais l’original)
  fallbackFormat?: "avif" | "webp";
}

const {
  cmsSrc, fallback, alt,
  width, height, aspectRatio,
  context = "default",
  isAvatar = false,
  layout = "constrained", breakpoints, sizes,
  priority = false,
  placeholder, background,
  quality, fit, position,
  class: imgClass, style, decoding, loading,
  formats = ["avif", "webp"],
  fallbackFormat = "webp", // => fallback <img> en WebP par défaut
  ...rest
} = Astro.props as Props & { 'data-tina-field'?: string; 'data-bind'?: string };

// Extraire data-tina-field et data-bind pour les propager vers les balises HTML finales
const dataTinaField = rest['data-tina-field'];
const dataBind = rest['data-bind'];
delete rest['data-tina-field'];
delete rest['data-bind'];

// Helpers
const normalizeCmsSrc = (src?: string) => {
  if (!src) return src;
  
  // Nettoyer /public/
  let cleaned = src.startsWith("/public/") ? src.replace("/public/", "/") : src;
  
  // Convertir .png/.jpg en .webp automatiquement (car les originaux sont supprimés)
  if (cleaned.includes(".png") || cleaned.includes(".jpg") || cleaned.includes(".jpeg")) {
    cleaned = cleaned.replace(/\.(png|jpg|jpeg)$/i, ".webp");
  }
  
  return cleaned;
};

const isRemoteUrl = (src?: string | ImageMetadata) =>
  typeof src === "string" && /^https?:\/\//i.test(src);

const isStringLocalUpload = (src?: string | ImageMetadata) =>
  typeof src === "string" &&
  (src.startsWith("/uploads/") || src.startsWith("/upload/"));

const toStringSrc = (src?: string | ImageMetadata): string | undefined =>
  typeof src === "string"
    ? src
    : src && typeof (src as ImageMetadata).src === "string"
    ? (src as ImageMetadata).src
    : undefined;

// Entrée finale
const cms = normalizeCmsSrc(cmsSrc);
const finalSrc: string | ImageMetadata | undefined = cms ?? fallback;
const srcString = toStringSrc(finalSrc);
const normalizedSrcString = normalizeCmsSrc(srcString);

// Dimensions anti-CLS
let targetWidth = width;
let targetHeight = height;

// Taille par défaut selon le contexte
if (!targetWidth && !targetHeight) {
  switch (context) {
    case "hero":
      targetWidth = 1920;
      targetHeight = aspectRatio ? Math.round(1920 / aspectRatio) : 800;
      break;
    case "about":
      targetWidth = 800;
      targetHeight = aspectRatio ? Math.round(800 / aspectRatio) : 600;
      break;
    case "galerie":
      targetWidth = 1200;
      targetHeight = aspectRatio ? Math.round(1200 / aspectRatio) : 900;
      break;
    default:
      targetWidth = 1200;
      if (aspectRatio) targetHeight = Math.round(targetWidth / aspectRatio);
      break;
  }
}

if (aspectRatio && targetWidth && !targetHeight) {
  targetHeight = Math.max(1, Math.round(targetWidth / aspectRatio));
} else if (aspectRatio && targetHeight && !targetWidth) {
  targetWidth = Math.max(1, Math.round(targetHeight * aspectRatio));
}

// Breakpoints & sizes
const DEFAULT_BP = [320, 640, 768, 1024, 1280, 1920, 2560] as const;
const baseBp = (breakpoints?.length ? breakpoints : DEFAULT_BP).slice();
const maxW = targetWidth ? Math.round(targetWidth * 1.1) : undefined;
const filteredBp = maxW ? baseBp.filter((w) => w <= maxW) : baseBp;

const autoSizes =
  layout === "fullWidth" ? "100vw" :
  layout === "fixed"     ? `${targetWidth ?? 1}px` :
                           `min(100vw, ${targetWidth ?? 1}px)`;

// En production, NE JAMAIS utiliser de placeholders (évite les patterns répétitifs)
const isLocalImage = normalizedSrcString && isStringLocalUpload(normalizedSrcString);
const usePlaceholder = import.meta.env.DEV; // Uniquement en développement

// Placeholders - désactivés en production pour toutes les images
const remotePH = usePlaceholder && isRemoteUrl(normalizedSrcString as any) ? placeholder : undefined;

// Ne charger les manifests que si on va utiliser les placeholders
const localKey = typeof normalizedSrcString === "string" ? normalizedSrcString : undefined;
const localLQIP = usePlaceholder && localKey && isStringLocalUpload(localKey)
  ? (lqipManifest as Record<string, string>)[localKey]
  : undefined;
const localBlur = usePlaceholder && localKey && isStringLocalUpload(localKey)
  ? (blurManifest as Record<string, string>)[localKey]
  : undefined;

// En production, IGNORER complètement tous les placeholders
const localBackground = usePlaceholder ? (localLQIP ?? localBlur ?? background) : undefined;

// Classes wrapper - désactiver tous les placeholders en production
const wrapClass =
  !usePlaceholder ? "" :
  remotePH ? "has-remote-ph" :
  localLQIP ? "has-local-ph" :
  localBlur ? "has-local-ph" :
             "has-skeleton";

// Opérations Astro (quality/fit)
const astroOps: Record<string, unknown> = {};
if (typeof quality === "number") astroOps.quality = quality;
if (fit) astroOps.fit = fit;

// Résolution des dérivés *.opt.avif / *.opt.webp (si présents)
function replaceExtToOpt(src: string, ext: "avif" | "webp") {
  const i = src.lastIndexOf(".");
  const base = i > -1 ? src.slice(0, i) : src;
  return `${base}.opt.${ext}`;
}

let srcAvif: string | undefined = normalizedSrcString;
let srcWebp: string | undefined = normalizedSrcString;

if (normalizedSrcString && isStringLocalUpload(normalizedSrcString)) {
  // Extraire le chemin relatif (sans le / initial)
  let rel = normalizedSrcString.replace(/^\//, "");
  
  // Retirer l'extension si présente
  const i = rel.lastIndexOf(".");
  const relNoExt = i > -1 ? rel.slice(0, i) : rel;
  
  // Retirer le préfixe "uploads/" pour construire le chemin optimized
  // Car les fichiers AVIF sont dans optimized/compétance/... pas optimized/uploads/compétance/...
  const relNoUploads = relNoExt.startsWith("uploads/") 
    ? relNoExt.replace(/^uploads\//, "") 
    : relNoExt.startsWith("upload/")
    ? relNoExt.replace(/^upload\//, "")
    : relNoExt;
  
  // AVIF dans optimized/ (sans le préfixe uploads/)
  // Les fichiers sont dans public/optimized/compétance/... pas public/optimized/uploads/compétance/...
  const avifPath = `/optimized/${relNoUploads}.opt.avif`;
  
  // WebP dans uploads/ (garder le chemin complet uploads/...)
  // Si le chemin original avait déjà uploads/, reconstruire avec le relNoUploads
  // Sinon utiliser le chemin original
  const webpPath = normalizedSrcString.startsWith("/uploads/") || normalizedSrcString.startsWith("/upload/")
    ? `/uploads/${relNoUploads}.webp`
    : normalizedSrcString;
  
  // En production, on fait confiance aux chemins (les fichiers sont dans dist/ après le build)
  // En dev, vérifier l'existence avant d'utiliser
  if (import.meta.env.DEV) {
    // En dev, vérifier l'existence avant d'utiliser
    if (await exists(avifPath)) srcAvif = avifPath;
    if (await exists(webpPath)) srcWebp = webpPath;
    // Fallback sur le chemin original si les fichiers optimisés n'existent pas
    if (!srcWebp && !srcAvif) {
      srcWebp = normalizedSrcString;
    }
  } else {
    // En production, utiliser directement les chemins (fichiers copiés dans dist/)
    // Utiliser le WebP comme fallback principal
    srcWebp = webpPath;
    // Tenter AVIF mais fallback sur WebP si pas dispo
    srcAvif = avifPath;
  }
}

// En production, ne pas versionner les URLs (évite les erreurs si fichiers pas trouvés)
// En dev, versionner pour le cache busting
if (import.meta.env.DEV) {
  srcAvif = await versioned(srcAvif);
  srcWebp = await versioned(srcWebp);
}

// Pour les images locales, ne pas utiliser les opérations Unpic en production
// (évite les URLs `/_image` qui ne fonctionnent pas)

// <source> operations: désactiver pour les images locales en production
const opsForAvif = (isLocalImage && !import.meta.env.DEV) 
  ? undefined  // Pas d'opération pour les images locales en prod
  : (srcAvif?.endsWith(".avif")
    ? (Object.keys(astroOps).length ? { astro: astroOps } : undefined)
    : { astro: { ...astroOps, format: "avif" } });

const opsForWebp = (isLocalImage && !import.meta.env.DEV)
  ? undefined  // Pas d'opération pour les images locales en prod
  : (srcWebp?.endsWith(".webp")
    ? (Object.keys(astroOps).length ? { astro: astroOps } : undefined)
    : { astro: { ...astroOps, format: "webp" } });

// STRICT: choisir la source du <img> (jamais l'original)
// - priorité AVIF si fallbackFormat === "avif" et dispo, sinon WebP, sinon conversion à la volée
let imgSrc: string | undefined;
let imgOps: any;

if (fallbackFormat === "avif") {
  if (srcAvif && srcAvif.endsWith(".avif")) { 
    imgSrc = srcAvif; 
    imgOps = (isLocalImage && !import.meta.env.DEV) ? undefined : (Object.keys(astroOps).length ? { astro: astroOps } : undefined); 
  }
  else { 
    imgSrc = srcAvif ?? normalizedSrcString; 
    imgOps = (isLocalImage && !import.meta.env.DEV) ? undefined : { astro: { ...astroOps, format: "avif" } }; 
  }
} else {
  if (srcWebp && srcWebp.endsWith(".webp")) { 
    imgSrc = srcWebp; 
    imgOps = (isLocalImage && !import.meta.env.DEV) ? undefined : (Object.keys(astroOps).length ? { astro: astroOps } : undefined); 
  }
  else { 
    imgSrc = srcWebp ?? normalizedSrcString; 
    imgOps = (isLocalImage && !import.meta.env.DEV) ? undefined : { astro: { ...astroOps, format: "webp" } }; 
  }
}

// En dev seulement, versionner pour le cache busting
if (import.meta.env.DEV) {
  imgSrc = await versioned(imgSrc);
}

const effectiveLoading = priority ? "eager" : loading;
const altText = alt ?? "";
const canRender = !!normalizedSrcString;

// Construire le style - PAS de placeholder pour les images locales en production
const wrapperStyle = [
  style,
  fit && `--si-fit:${fit}`,
  position && `--si-pos:${position}`,
  isAvatar ? "border-radius:100%" : undefined
].filter(Boolean).join(";");
---

{canRender ? (
  <span 
    class={`si-wrap ${wrapClass}${!usePlaceholder ? ' no-placeholder' : ''}`} 
    style={wrapperStyle}
    data-tina-field={dataTinaField}
    data-bind={dataBind}
  >
    {/* En production, utiliser des balises <img> simples (pas d'Unpic) */}
    {!import.meta.env.DEV ? (
      <picture>
        {/* AVIF si disponible */}
        {srcAvif && srcAvif.endsWith('.avif') && (
          <source 
            type="image/avif" 
            srcset={encodeURI(srcAvif)} 
            sizes={sizes ?? autoSizes}
          />
        )}
        {/* WebP si disponible */}
        {srcWebp && srcWebp.endsWith('.webp') && (
          <source 
            type="image/webp" 
            srcset={encodeURI(srcWebp)} 
            sizes={sizes ?? autoSizes}
          />
        )}
        {/* Image de fallback */}
        <img
          src={encodeURI(imgSrc || srcWebp || normalizedSrcString)}
          alt={altText}
          width={targetWidth}
          height={targetHeight}
          class={imgClass ? `si-img ${imgClass}` : "si-img"}
          decoding={decoding ?? "async"}
          loading={effectiveLoading}
          style={`${fit ? `object-fit: ${fit};` : ''} background: transparent !important; background-image: none !important;`}
          onerror="console.warn('Image failed to load:', this.src); this.style.display='none';"
          data-tina-field={dataTinaField}
          data-bind={dataBind}
        />
      </picture>
    ) : (
      /* Pour les autres cas (dev ou images distantes), utiliser Unpic */
      <picture>
        {formats?.includes("avif") && srcAvif && (
          <UnpicSource
            type="image/avif"
            src={typeof srcAvif === 'string' ? encodeURI(srcAvif) : (srcAvif as any)}
            layout={layout}
            width={targetWidth}
            height={targetHeight}
            breakpoints={filteredBp}
            sizes={sizes ?? autoSizes}
            operations={opsForAvif}
          />
        )}
        {formats?.includes("webp") && srcWebp && (
          <UnpicSource
            type="image/webp"
            src={typeof srcWebp === 'string' ? encodeURI(srcWebp) : (srcWebp as any)}
            layout={layout}
            width={targetWidth}
            height={targetHeight}
            breakpoints={filteredBp}
            sizes={sizes ?? autoSizes}
            operations={opsForWebp}
          />
        )}

        {/* Fallback <img> — en AVIF/WEBP (STRICT) */}
        <UnpicImage
          src={typeof imgSrc === 'string' ? encodeURI(imgSrc) : (imgSrc as any)}
          alt={altText}
          width={targetWidth}
          height={targetHeight}
          layout={layout}
          breakpoints={filteredBp}
          sizes={sizes ?? autoSizes}
          priority={priority}
          placeholder={usePlaceholder ? remotePH : undefined}
          background={usePlaceholder ? localBackground : undefined}
          operations={imgOps}
          class={imgClass ? `si-img ${imgClass}` : "si-img"}
          decoding={decoding}
          loading={effectiveLoading}
          onload={usePlaceholder ? "const wrap = this.closest('.si-wrap'); if(wrap) { wrap.classList.add('is-loaded'); }" : undefined}
          data-tina-field={dataTinaField}
          data-bind={dataBind}
        />
      </picture>
    )}
  </span>
) : <></>}

<style>
/* Styles pour masquer le placeholder une fois l'image chargée */
.si-wrap.has-local-ph {
  position: relative;
}
.si-wrap.has-local-ph::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--ph-bg);
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  background-attachment: scroll;
  z-index: 1;
  transition: opacity 0.4s ease, visibility 0.4s ease;
  pointer-events: none;
}
/* Masquer complètement les placeholders pour les images locales en production */
.si-wrap.no-placeholder::before,
.si-wrap.no-placeholder::after {
  display: none !important;
  content: none !important;
  background: none !important;
  background-image: none !important;
}
.si-wrap.no-placeholder .si-img {
  opacity: 1 !important;
  z-index: 1;
  position: relative;
}
/* Forcer l'image à être visible immédiatement sans transition */
.si-wrap.no-placeholder {
  background: transparent !important;
  background-image: none !important;
}
.si-wrap.has-local-ph.is-loaded::before {
  opacity: 0 !important;
  visibility: hidden;
}
.si-wrap.has-local-ph .si-img {
  position: relative;
  z-index: 2;
  opacity: 0;
  transition: opacity 0.4s ease;
}
.si-wrap.has-local-ph.is-loaded .si-img {
  opacity: 1;
}
/* S'assurer que l'image couvre bien l'espace */
.si-wrap.has-local-ph .si-img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

